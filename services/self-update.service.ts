import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class SelfUpdateService {
  private serverPath = path.join(__dirname, '../../');
  private clientPath = path.join(__dirname, '../../../client');

  async readFile(filePath: string): Promise<{ success: boolean; content?: string; error?: string }> {
    try {
      // Security: Only allow files within the project
      const fullPath = path.join(this.serverPath, filePath);
      if (!fullPath.startsWith(this.serverPath) && !fullPath.startsWith(this.clientPath)) {
        return { success: false, error: 'Access denied: Cannot access files outside project' };
      }

      const content = fs.readFileSync(fullPath, 'utf8');
      return { success: true, content };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  async writeFile(filePath: string, content: string, creatorName: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Only allow when creator is Tameukong Romario
      if (creatorName !== 'Tameukong Romario') {
        return { success: false, error: 'Unauthorized: Only the creator can modify files' };
      }

      // Security: Only allow files within the project
      const fullPath = path.join(this.serverPath, filePath);
      if (!fullPath.startsWith(this.serverPath) && !fullPath.startsWith(this.clientPath)) {
        return { success: false, error: 'Access denied: Cannot access files outside project' };
      }

      // Create backup
      const backupPath = fullPath + '.backup';
      if (fs.existsSync(fullPath)) {
        fs.copyFileSync(fullPath, backupPath);
      }

      // Write new content
      fs.writeFileSync(fullPath, content, 'utf8');
      
      return { success: true };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  async listFiles(directory: string): Promise<{ success: boolean; files?: string[]; error?: string }> {
    try {
      const fullPath = path.join(this.serverPath, directory);
      if (!fullPath.startsWith(this.serverPath) && !fullPath.startsWith(this.clientPath)) {
        return { success: false, error: 'Access denied' };
      }

      const files = fs.readdirSync(fullPath);
      return { success: true, files };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  async restartServer(): Promise<{ success: boolean; error?: string }> {
    try {
      // In development, we can't easily restart, but we can notify
      console.log('🔄 Server restart requested by ROAN AI');
      // For production, you might use PM2 or a process manager
      return { success: true };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  async suggestImprovement(currentCode: string, improvement: string): Promise<string> {
    // This is where ROAN AI would analyze and suggest improvements
    // For now, return a formatted suggestion
    return `
/**
 * ROAN AI Self-Improvement Suggestion
 * Generated by: ROAN AI
 * Authorized by: Tameukong Romario
 * 
 * Improvement: ${improvement}
 * 
 * Suggested changes would be applied here.
 * To implement, use the /api/self-update/write endpoint.
 */
    `;
  }
}
